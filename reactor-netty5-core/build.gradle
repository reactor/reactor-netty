/*
 * Copyright (c) 2020-2024 VMware, Inc. or its affiliates, All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import aQute.bnd.gradle.BundleTaskConvention
import me.champeau.gradle.japicmp.JapicmpTask

apply plugin: 'java-test-fixtures'
apply plugin: 'io.spring.javadoc'
apply plugin: 'com.github.johnrengelman.shadow'
apply plugin: 'me.champeau.gradle.japicmp'
apply plugin: 'de.undercouch.download'
apply plugin: 'biz.aQute.bnd.builder'

ext {
	bndOptions = [
			"Export-Package" : "reactor.netty5*;version=$osgiVersion;-noimport:=true",
			"Import-Package": [
					"!javax.annotation",
					"io.netty5.channel.kqueue;resolution:=optional;version=\"[5.0,6)\"",
					"io.netty.incubator.channel.uring;resolution:=optional",
					"io.micrometer.*;resolution:=optional",
					"*"
			].join(","),
			"Bundle-Name" : "reactor-netty5-core",
			"Bundle-SymbolicName" : "io.projectreactor.netty.reactor-netty5-core",
			"Bundle-Version" : "$osgiVersion"
	]
}

sourceSets {
	jarFileTest
	contextPropagationTest {
		compileClasspath += sourceSets.main.output
		runtimeClasspath += sourceSets.main.output
	}
}

configurations {
	shaded
	contextPropagationTestImplementation.extendsFrom(implementation)
	contextPropagationTestRuntimeOnly.extendsFrom(runtimeOnly)
}

dependencies {
	// JSR-305 annotations
	compileOnly "com.google.code.findbugs:jsr305:$jsr305Version"

	api "io.netty:netty5-handler:$nettyVersion"
	api("io.netty.contrib:netty-handler-proxy:$nettyContribHandlerProxyVersion") {
		exclude module: "netty5-codec-http"
	}
	api "io.netty:netty5-resolver-dns:$nettyVersion"
	if (!"$nettyVersion".endsWithAny("SNAPSHOT")) {
		if (osdetector.classifier == "osx-x86_64" || osdetector.classifier == "osx-aarch_64") {
			testImplementation "io.netty:netty5-resolver-dns-native-macos:$nettyVersion$os_suffix"
		}
		else {
			testImplementation "io.netty:netty5-resolver-dns-classes-macos:$nettyVersion"
		}
	}
	else {
		// MacOS binaries are not available for Netty SNAPSHOT version
		testImplementation "io.netty:netty5-resolver-dns-classes-macos:$nettyVersion"
	}
	//transport resolution: typical build forces epoll but not kqueue transitively
	//on the other hand, if we want to make transport-specific tests, we'll make all
	// native optional at compile time and add correct native/nio to testRuntime
	if (project.hasProperty("forceTransport")) {
		//so that the main code compiles
		compileOnly "io.netty:netty5-transport-classes-epoll:$nettyVersion"
		compileOnly "io.netty:netty5-transport-classes-kqueue:$nettyVersion"
		compileOnly "io.netty:netty5-transport-classes-io_uring:$nettyVersion"
		testImplementation "io.netty:netty5-transport-classes-epoll:$nettyVersion"
		testImplementation "io.netty:netty5-transport-classes-kqueue:$nettyVersion"
		testImplementation "io.netty:netty5-transport-classes-io_uring:$nettyVersion"
		//now we explicitly add correctly qualified native, or do nothing if we want to test NIO
		if (forceTransport == "native") {
			if (osdetector.os == "osx") {
				testImplementation "io.netty:netty5-transport-native-kqueue:$nettyVersion$os_suffix"
			}
			else if (osdetector.os == "linux") {
				testImplementation "io.netty:netty5-transport-native-epoll:$nettyVersion$os_suffix"
			}
		}
		else if (forceTransport == "io_uring" && osdetector.os == "linux") {
			testImplementation "io.netty:netty5-transport-native-io_uring:$nettyVersion$os_suffix"
		}
		else if (forceTransport != "nio") {
			throw new InvalidUserDataException("invalid -PforceTranport option " + forceTransport + ", should be native|nio")
		}
	}
	else {
		//classic build to be distributed
		api "io.netty:netty5-transport-native-epoll:$nettyVersion:linux-x86_64"
		compileOnly "io.netty:netty5-transport-classes-kqueue:$nettyVersion"
		compileOnly "io.netty:netty5-transport-classes-io_uring:$nettyVersion"
		testImplementation "io.netty:netty5-transport-classes-kqueue:$nettyVersion"
		testImplementation "io.netty:netty5-transport-classes-io_uring:$nettyVersion"
	}

	//Metrics
	compileOnly "io.micrometer:micrometer-core:$micrometerVersion"
	compileOnly "io.micrometer:micrometer-tracing:$micrometerTracingVersion"
	compileOnly "io.micrometer:context-propagation:$contextPropagationVersion"

	// Logging
	compileOnly "org.slf4j:slf4j-api:$slf4jVersion"

	api "io.projectreactor:reactor-core:$reactorCoreVersion"
	shaded("io.projectreactor.addons:reactor-pool:$reactorPoolVersion") {
		exclude module: "reactor-core"
	}

	// Testing

	// JSR-305 annotations
	testCompileOnly "com.google.code.findbugs:jsr305:$jsr305Version"

	testImplementation "com.fasterxml.jackson.core:jackson-databind:$jacksonDatabindVersion"
	testImplementation "io.projectreactor:reactor-test:$testAddonVersion"
	testImplementation "io.projectreactor.addons:reactor-extra:$reactorAddonsVersion"
	testImplementation "org.assertj:assertj-core:$assertJVersion"
	testImplementation "org.awaitility:awaitility:$awaitilityVersion"
	testImplementation "org.junit.jupiter:junit-jupiter-api:$junitVersion"
	testImplementation "org.junit.jupiter:junit-jupiter-params:$junitVersion"
	testImplementation "org.mockito:mockito-core:$mockitoVersion"
	testImplementation "ch.qos.logback:logback-classic:$logbackVersion"
	testImplementation "io.projectreactor.tools:blockhound-junit-platform:$blockHoundVersion"
	testImplementation "io.micrometer:micrometer-core:$micrometerVersion"
	testImplementation "io.netty.contrib:netty-codec-extras:$nettyContribVersion"
	testImplementation "org.reflections:reflections:$reflectionsVersion"

	testRuntimeOnly "org.junit.platform:junit-platform-launcher:$junitPlatformLauncherVersion"
	testRuntimeOnly "org.junit.jupiter:junit-jupiter-engine:$junitVersion"
	testRuntimeOnly "org.slf4j:jcl-over-slf4j:$slf4jVersion"

	// https://github.com/netty/netty/pull/11487
	// https://github.com/netty/netty/issues/10317
	// Necessary for generating SelfSignedCertificate on Java version >= 15
	testRuntimeOnly "org.bouncycastle:bcpkix-jdk15on:$bouncycastleVersion"

	// JSR-305 annotations
	testFixturesCompileOnly "com.google.code.findbugs:jsr305:$jsr305Version"
	testFixturesApi("ch.qos.logback:logback-classic:$logbackVersion")
	testFixturesApi("io.micrometer:micrometer-core:$micrometerVersion")
	testFixturesApi("org.assertj:assertj-core:$assertJVersion")

	for (dependency in project.configurations.shaded.dependencies) {
		compileOnly(dependency)
		testImplementation(dependency)
		contextPropagationTestImplementation(dependency)
	}

	jarFileTestImplementation "org.assertj:assertj-core:$assertJVersion"
	jarFileTestImplementation "org.junit.jupiter:junit-jupiter-api:$junitVersion"
	jarFileTestRuntimeOnly "org.junit.jupiter:junit-jupiter-engine:$junitVersion"

	contextPropagationTestImplementation "io.projectreactor:reactor-test:$testAddonVersion"
	contextPropagationTestImplementation "org.assertj:assertj-core:$assertJVersion"
	contextPropagationTestImplementation "org.junit.jupiter:junit-jupiter-api:$junitVersion"
	contextPropagationTestImplementation "org.junit.jupiter:junit-jupiter-params:$junitVersion"
	contextPropagationTestImplementation "ch.qos.logback:logback-classic:$logbackVersion"
	contextPropagationTestImplementation "io.micrometer:micrometer-core:$micrometerVersion"
	contextPropagationTestImplementation "io.micrometer:context-propagation:$contextPropagationVersion"
	contextPropagationTestRuntimeOnly "org.junit.jupiter:junit-jupiter-engine:$junitVersion"
}

jar {
	archiveClassifier.set('original')
	manifest {
		attributes("Automatic-Module-Name": "reactor.netty5.core")
	}
	bnd(bndOptions)
}

components.java.withVariantsFromConfiguration(configurations.testFixturesApiElements) { skip() }
components.java.withVariantsFromConfiguration(configurations.testFixturesRuntimeElements) { skip() }

task downloadBaseline(type: Download) {
	onlyIf {
		if (project.gradle.startParameter.isOffline()) {
			println "Offline: skipping downloading of baseline and JAPICMP"
			return false
		}
		else if ("$compatibleVersion" == "SKIP") {
			println "SKIP: Instructed to skip the baseline comparison"
			return false
		}
		else {
			println "Will download and perform baseline comparison with ${compatibleVersion}"
			return true
		}
	}

	onlyIfNewer true
	compress true
	src "${repositories.mavenCentral().url}io/projectreactor/netty/reactor-netty-core/$compatibleVersion/reactor-netty-core-${compatibleVersion}-original.jar"
	dest "${buildDir}/baselineLibs/reactor-netty-core-${compatibleVersion}-original.jar"
}

def japicmpReport = tasks.register('japicmpReport') {
	onlyIf {
		japicmp.state.failure != null
	}
	doLast {
		def reportFile = file("${project.buildDir}/reports/japi.txt")
		if (reportFile.exists()) {
			println "\n **********************************"
			println " * /!\\ API compatibility failures *"
			println " **********************************"
			println "Japicmp report was filtered and interpreted to find the following incompatibilities:"
			reportFile.eachLine {
				if (it.contains("*") && (!it.contains("***") || it.contains("****")))
					println "source incompatible change: $it"
				else if (it.contains("!"))
					println "binary incompatible change: $it"
			}
		}
		else println "No incompatible change to report"
	}
}

task japicmp(type: JapicmpTask) {
	finalizedBy(japicmpReport)
	onlyIf { "$compatibleVersion" != "SKIP" }

	oldClasspath.from(files("${buildDir}/baselineLibs/reactor-netty-core-${compatibleVersion}-original.jar"))
	newClasspath.from(files(jar.archiveFile))
	// these onlyXxx parameters result in a report that is slightly too noisy, but better than
	// onlyBinaryIncompatibleModified = true which masks source-incompatible-only changes
	onlyBinaryIncompatibleModified = false
	onlyModified = true
	failOnModification = true
	failOnSourceIncompatibility = true
	txtOutputFile = file("${project.buildDir}/reports/japi.txt")
	ignoreMissingClasses = true
	includeSynthetic = true

	compatibilityChangeExcludes = [ "METHOD_NEW_DEFAULT" ]
	fieldExcludes = [
			// Deprecated field is removed
			'reactor.netty.NettyPipeline#UnvoidHandler',

			// Removed fields because of the new Buffer API
			'reactor.netty.Metrics#ACTIVE_DIRECT_MEMORY',
			'reactor.netty.Metrics#ACTIVE_HEAP_MEMORY',
			'reactor.netty.Metrics#BYTE_BUF_ALLOCATOR_PREFIX',
			'reactor.netty.Metrics#DIRECT_ARENAS',
			'reactor.netty.Metrics#HEAP_ARENAS',
			'reactor.netty.Metrics#USED_DIRECT_MEMORY',
			'reactor.netty.Metrics#USED_HEAP_MEMORY'
	]
	methodExcludes = [
			'reactor.netty.NettyInbound#receive()',
			'reactor.netty.NettyOutbound#alloc()',
			'reactor.netty.NettyOutbound#send(org.reactivestreams.Publisher, java.util.function.Predicate)',

			'reactor.netty.channel.ChannelOperations#alloc()',
			'reactor.netty.channel.ChannelOperations#receive()',
			'reactor.netty.channel.ChannelOperations#send(org.reactivestreams.Publisher, java.util.function.Predicate)',

			'reactor.netty.resources.LoopResources#onChannel(java.lang.Class, io.netty.channel.EventLoopGroup)',
			'reactor.netty5.resources.LoopResources#onChannel(java.lang.Class, io.netty5.channel.EventLoop, java.net.ProtocolFamily)', // new default method
			'reactor.netty.resources.LoopResources#onChannelClass(java.lang.Class, io.netty.channel.EventLoopGroup)',
			'reactor.netty5.resources.LoopResources#onServerChannel(java.lang.Class, io.netty5.channel.EventLoop, io.netty5.channel.EventLoopGroup, java.net.ProtocolFamily)', // new default method

			'reactor.netty.tcp.TcpResources#onChannel(java.lang.Class, io.netty.channel.EventLoopGroup)',
			'reactor.netty.tcp.TcpResources#onChannelClass(java.lang.Class, io.netty.channel.EventLoopGroup)',

			'reactor.netty.udp.UdpClient#runOn(reactor.netty.resources.LoopResources, io.netty.channel.socket.InternetProtocolFamily)',
			'reactor.netty.udp.UdpResources#onChannel(java.lang.Class, io.netty.channel.EventLoopGroup)',
			'reactor.netty.udp.UdpResources#onChannelClass(java.lang.Class, io.netty.channel.EventLoopGroup)',
			'reactor.netty.udp.UdpServer#runOn(reactor.netty.resources.LoopResources, io.netty.channel.socket.InternetProtocolFamily)',

			// Deprecated methods are removed
			'reactor.netty.Connection#addHandler(io.netty.channel.ChannelHandler)',
			'reactor.netty.Connection#addHandler(java.lang.String, io.netty.channel.ChannelHandler)',
			'reactor.netty.ReactorNetty#toPrettyHexDump(java.lang.Object)',

			'reactor.netty.tcp.SslProvider$SslContextSpec#sslContext(io.netty.handler.ssl.SslContextBuilder)',
			'reactor.netty.tcp.SslProvider#getDefaultConfigurationType()',
			'reactor.netty.tcp.SslProvider#updateDefaultConfiguration(reactor.netty.tcp.SslProvider, reactor.netty.tcp.SslProvider$DefaultConfigurationType)',
			'reactor.netty.tcp.TcpClient#addressSupplier(java.util.function.Supplier)',
			'reactor.netty.tcp.TcpClient#bootstrap(java.util.function.Function)',

			// Changes related to Netty 5 package change
			'reactor.netty.ChannelPipelineConfigurer#onChannelInit(reactor.netty.ConnectionObserver, io.netty.channel.Channel, java.net.SocketAddress)',
			'reactor.netty.Connection#addHandlerFirst(io.netty.channel.ChannelHandler)',
			'reactor.netty.Connection#addHandlerFirst(io.netty5.channel.ChannelHandler)', // new default method
			'reactor.netty.Connection#addHandlerFirst(java.lang.String, io.netty.channel.ChannelHandler)',
			'reactor.netty.Connection#addHandlerFirst(java.lang.String, io.netty5.channel.ChannelHandler)', // new default method
			'reactor.netty.Connection#addHandlerLast(io.netty.channel.ChannelHandler)',
			'reactor.netty.Connection#addHandlerLast(io.netty5.channel.ChannelHandler)', // new default method
			'reactor.netty.Connection#addHandlerLast(java.lang.String, io.netty.channel.ChannelHandler)',
			'reactor.netty.Connection#addHandlerLast(java.lang.String, io.netty5.channel.ChannelHandler)', // new default method
			'reactor.netty.Connection#from(io.netty.channel.Channel)',
			'reactor.netty.Connection#from(io.netty5.channel.Channel)', // new default method
			'reactor.netty.Connection#replaceHandler(java.lang.String, io.netty.channel.ChannelHandler)',
			'reactor.netty.Connection#replaceHandler(java.lang.String, io.netty5.channel.ChannelHandler)', // new default method
			'reactor.netty.DisposableChannel#channel()',
			'reactor.netty.NettyPipeline#inboundHandler(java.util.function.BiConsumer)',
			'reactor.netty.ReactorNetty#format(io.netty.channel.Channel, java.lang.String)',

			'reactor.netty.channel.AbstractChannelMetricsHandler#channelActive(io.netty.channel.ChannelHandlerContext)',
			'reactor.netty.channel.AbstractChannelMetricsHandler#channelInactive(io.netty.channel.ChannelHandlerContext)',
			'reactor.netty.channel.AbstractChannelMetricsHandler#channelRead(io.netty.channel.ChannelHandlerContext, java.lang.Object)',
			'reactor.netty.channel.AbstractChannelMetricsHandler#channelRegistered(io.netty.channel.ChannelHandlerContext)',
			'reactor.netty.channel.AbstractChannelMetricsHandler#connectMetricsHandler()',
			'reactor.netty.channel.AbstractChannelMetricsHandler#exceptionCaught(io.netty.channel.ChannelHandlerContext, java.lang.Throwable)',
			'reactor.netty.channel.AbstractChannelMetricsHandler#tlsMetricsHandler()',
			'reactor.netty.channel.AbstractChannelMetricsHandler#write(io.netty.channel.ChannelHandlerContext, java.lang.Object, io.netty.channel.ChannelPromise)',
			'reactor.netty.channel.ChannelMetricsHandler#connectMetricsHandler()',
			'reactor.netty.channel.ChannelMetricsHandler#tlsMetricsHandler()',
			'reactor.netty.channel.ChannelOperations#addMetricsHandler(io.netty.channel.Channel, reactor.netty.channel.ChannelMetricsRecorder, java.net.SocketAddress, boolean)',
			'reactor.netty.channel.ChannelOperations#addReactiveBridge(io.netty.channel.Channel, reactor.netty.channel.ChannelOperations$OnSetup, reactor.netty.ConnectionObserver)',
			'reactor.netty.channel.ChannelOperations#channel()',
			'reactor.netty.channel.ChannelOperations#get(io.netty.channel.Channel)',

			'reactor.netty.resources.ConnectionProvider#acquire(reactor.netty.transport.TransportConfig, reactor.netty.ConnectionObserver, java.util.function.Supplier, io.netty.resolver.AddressResolverGroup)',
			'reactor.netty.resources.LoopResources#colocate(io.netty.channel.EventLoopGroup)',
			'reactor.netty.resources.LoopResources#colocate(io.netty5.channel.EventLoopGroup)', // new default method
			'reactor.netty.resources.LoopResources#onClient(boolean)',
			'reactor.netty.resources.LoopResources#onServer(boolean)',
			'reactor.netty.resources.LoopResources#onServerSelect(boolean)',
			'reactor.netty.resources.PooledConnectionProvider#acquire(reactor.netty.transport.TransportConfig, reactor.netty.ConnectionObserver, java.util.function.Supplier, io.netty.resolver.AddressResolverGroup)',

			'reactor.netty.tcp.AbstractProtocolSslContextSpec#sslContext()',
			'reactor.netty.tcp.SslProvider#addSslHandler(io.netty.channel.Channel, java.net.SocketAddress, boolean)',
			'reactor.netty.tcp.SslProvider#configure(io.netty.handler.ssl.SslHandler)',
			'reactor.netty.tcp.SslProvider#getSslContext()',
			'reactor.netty.tcp.SslProvider$Builder#setSniAsyncMappings(io.netty.util.AsyncMapping)',
			'reactor.netty.tcp.SslProvider$ProtocolSslContextSpec#sslContext()',
			'reactor.netty.tcp.SslProvider$SslContextSpec#sslContext(io.netty.handler.ssl.SslContext)',
			'reactor.netty.tcp.TcpClient#attr(io.netty.util.AttributeKey, java.lang.Object)',
			'reactor.netty.tcp.TcpClient#option(io.netty.channel.ChannelOption, java.lang.Object)',
			'reactor.netty.tcp.TcpClient#resolver(io.netty.resolver.AddressResolverGroup)',
			'reactor.netty.tcp.TcpClient#runOn(io.netty.channel.EventLoopGroup)',
			'reactor.netty.tcp.TcpClient#wiretap(java.lang.String, io.netty.handler.logging.LogLevel)',
			'reactor.netty.tcp.TcpResources#acquire(reactor.netty.transport.TransportConfig, reactor.netty.ConnectionObserver, java.util.function.Supplier, io.netty.resolver.AddressResolverGroup)',
			'reactor.netty.tcp.TcpResources#onClient(boolean)',
			'reactor.netty.tcp.TcpResources#onServer(boolean)',
			'reactor.netty.tcp.TcpResources#onServerSelect(boolean)',
			'reactor.netty.tcp.TcpServer#channelGroup(io.netty.channel.group.ChannelGroup)',
			'reactor.netty.tcp.TcpServer#runOn(io.netty.channel.EventLoopGroup)',
			'reactor.netty.tcp.TcpServer#wiretap(java.lang.String, io.netty.handler.logging.LogLevel)',

			'reactor.netty.transport.ClientTransport#resolver(io.netty.resolver.AddressResolverGroup)',
			'reactor.netty.transport.ClientTransportConfig#resolver()',
			'reactor.netty.transport.NameResolverProvider#hostsFileEntriesResolver()',
			'reactor.netty.transport.NameResolverProvider#newNameResolverGroup(reactor.netty.resources.LoopResources, boolean)',
			'reactor.netty.transport.NameResolverProvider#resolvedAddressTypes()',
			'reactor.netty.transport.NameResolverProvider$NameResolverSpec#hostsFileEntriesResolver(io.netty.resolver.HostsFileEntriesResolver)',
			'reactor.netty.transport.NameResolverProvider$NameResolverSpec#resolvedAddressTypes(io.netty.resolver.ResolvedAddressTypes)',
			'reactor.netty.transport.NameResolverProvider$NameResolverSpec#runOn(io.netty.channel.EventLoopGroup)',
			'reactor.netty.transport.NameResolverProvider$NameResolverSpec#trace(java.lang.String, io.netty.handler.logging.LogLevel)',
			'reactor.netty.transport.ProxyProvider#addProxyHandler(io.netty.channel.Channel)',
			'reactor.netty.transport.ProxyProvider#newProxyHandler()',
			'reactor.netty.transport.ServerTransport#childAttr(io.netty.util.AttributeKey, java.lang.Object)',
			'reactor.netty.transport.ServerTransport#childOption(io.netty.channel.ChannelOption, java.lang.Object)',
			'reactor.netty.transport.Transport#attr(io.netty.util.AttributeKey, java.lang.Object)',
			'reactor.netty.transport.Transport#channelGroup(io.netty.channel.group.ChannelGroup)',
			'reactor.netty.transport.Transport#option(io.netty.channel.ChannelOption, java.lang.Object)',
			'reactor.netty.transport.Transport#runOn(io.netty.channel.EventLoopGroup)',
			'reactor.netty.transport.Transport#wiretap(java.lang.String, io.netty.handler.logging.LogLevel)',
			'reactor.netty.transport.Transport#wiretap(java.lang.String, io.netty.handler.logging.LogLevel, reactor.netty.transport.logging.AdvancedByteBufFormat)',
			'reactor.netty.transport.Transport#wiretap(java.lang.String, io.netty.handler.logging.LogLevel, reactor.netty.transport.logging.AdvancedByteBufFormat, java.nio.charset.Charset)',
			'reactor.netty.transport.TransportConfig#channelGroup()',
			'reactor.netty.transport.TransportConfig#channelInitializer(reactor.netty.ConnectionObserver, java.net.SocketAddress, boolean)',
			'reactor.netty.transport.TransportConfig#loggingHandler()',
			'reactor.netty.transport.TransportConnector#bind(reactor.netty.transport.TransportConfig, io.netty.channel.ChannelInitializer, java.net.SocketAddress, boolean)',
			'reactor.netty.transport.TransportConnector#connect(reactor.netty.transport.TransportConfig, java.net.SocketAddress, io.netty.resolver.AddressResolverGroup, io.netty.channel.ChannelInitializer)',
			'reactor.netty.transport.TransportConnector#connect(reactor.netty.transport.TransportConfig, java.net.SocketAddress, io.netty.resolver.AddressResolverGroup, io.netty.channel.ChannelInitializer, io.netty.channel.EventLoop)',

			"reactor.netty.transport.logging.AdvancedByteBufFormat#toLoggingHandler(java.lang.String, io.netty.handler.logging.LogLevel, java.nio.charset.Charset)",

			'reactor.netty.udp.UdpClient#attr(io.netty.util.AttributeKey, java.lang.Object)',
			'reactor.netty.udp.UdpClient#option(io.netty.channel.ChannelOption, java.lang.Object)',
			'reactor.netty.udp.UdpClient#runOn(io.netty.channel.EventLoopGroup)',
			'reactor.netty.udp.UdpClient#runOn(reactor.netty.resources.LoopResources, io.netty.channel.socket.InternetProtocolFamily)',
			'reactor.netty.udp.UdpClient#wiretap(java.lang.String, io.netty.handler.logging.LogLevel)',
			'reactor.netty.udp.UdpClientConfig#family()',
			'reactor.netty.udp.UdpResources#onClient(boolean)',
			'reactor.netty.udp.UdpResources#onServer(boolean)',
			'reactor.netty.udp.UdpResources#onServerSelect(boolean)',
			'reactor.netty.udp.UdpServer#attr(io.netty.util.AttributeKey, java.lang.Object)',
			'reactor.netty.udp.UdpServer#option(io.netty.channel.ChannelOption, java.lang.Object)',
			'reactor.netty.udp.UdpServer#runOn(io.netty.channel.EventLoopGroup)',
			'reactor.netty.udp.UdpServer#runOn(reactor.netty.resources.LoopResources, io.netty.channel.socket.InternetProtocolFamily)',
			'reactor.netty.udp.UdpServer#wiretap(java.lang.String, io.netty.handler.logging.LogLevel)',
			'reactor.netty.udp.UdpServerConfig#family()'
	]
	classExcludes = [
			// Renamed class
			"reactor.netty.ByteBufFlux",
			"reactor.netty.ByteBufMono",

			// Unused class is removed
			"reactor.netty.FutureMono",

			// Deprecated classes are removed
			'reactor.netty.tcp.SslProvider$DefaultConfigurationSpec',
			'reactor.netty.tcp.SslProvider$DefaultConfigurationType'
	]
}

tasks.japicmp.dependsOn(downloadBaseline)

tasks.check.dependsOn(japicmp)

shadowJar {
	configure {
		it.convention.plugins.bundle = new BundleTaskConvention(it)
		doLast {
			buildBundle()
		}
	}
	bnd(bndOptions)

	enableRelocation true
	relocationPrefix "reactor.netty.internal.shaded"
	archiveClassifier.set('')

	dependsOn(project.tasks.jar)

	manifest {
		inheritFrom project.tasks.jar.manifest
	}

	configurations = [project.configurations.shaded]

	project.afterEvaluate {
		dependencies {
			def shadedDependencies = project.configurations
					.shaded
					.dependencies
					.collect { "${it.group}:${it.name}".toString() }
					.toSet()

			// Exclude every compile-scoped dependency (including the transitive ones)
			for (id in project.configurations.compileClasspath.resolvedConfiguration.resolvedArtifacts*.moduleVersion*.id) {
				def module = "${id.group}:${id.name}".toString()
				if (!shadedDependencies.contains(module)) {
					project.configurations.shaded.exclude(group: id.group, module: id.name)
					exclude(dependency(module))
				}
			}
		}
	}

	exclude 'META-INF/maven*/**'
}

//delay the maven publishing so that the OSGi metadata is generated
//then add shadowJar to the publication
components.java.withVariantsFromConfiguration(configurations.shadowRuntimeElements) {
	skip()
}
publishing.publications.mavenJava.artifact(shadowJar)

task jarFileTest(type: Test) {
	testClassesDirs = sourceSets.jarFileTest.output.classesDirs
	classpath = sourceSets.jarFileTest.runtimeClasspath

	systemProperty("jarFile", shadowJar.outputs.files.singleFile)

	dependsOn(shadowJar)
}

tasks.check.dependsOn(jarFileTest)

task contextPropagationTest(type: Test) {
	testClassesDirs = sourceSets.contextPropagationTest.output.classesDirs
	classpath = sourceSets.contextPropagationTest.runtimeClasspath
}

tasks.check.dependsOn(contextPropagationTest)

task shadedJarTest(type: Test) {
	testClassesDirs = sourceSets.test.output.classesDirs

	Set<? super File> mainOutputs = [
			project.sourceSets.main.output.resourcesDir,
			project.sourceSets.main.java.classesDirectory,
	]

	classpath = shadowJar.outputs.files
	// Exclude main outputs since we have the shaded JAR on the classpath already
	classpath += sourceSets.test.runtimeClasspath.filter { !(it in mainOutputs) }

	//The imports are not relocated, we do relocation only for the main sources not the tests
	exclude '**/*PooledConnectionProviderTest*.*'

	dependsOn(shadowJar)
}

tasks.check.dependsOn(shadedJarTest)

description = "Core functionality for the Reactor Netty library"
